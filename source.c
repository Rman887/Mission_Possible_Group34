#pragma config(Motor,  port2,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           frontRight,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int ROT_90_POWER = 50;

typedef struct {
	int speed;

} robot;

bool manualControl = true;



int stuff;
/*void moveForward(int power)
{
	motor[motorA] = -power;
	motor[motorB] = power;
	motor[motorC] = -power;
	motor[motorD] = power;
}*/

void moveForward(double dist)
{
	motor[frontLeft] = 1000;
	motor[backLeft] = 1000;
	motor[frontRight] = 1000;
	motor[backRight] = 1000;
	wait1Msec(dist * 17);
}

void rotate(int angle)
{
	int sign = 1;
	if (angle < 0) sign = -1;

	motor[frontLeft] = sign * ROT_90_POWER;
	motor[backLeft] = sign * ROT_90_POWER;
	motor[frontRight] = -sign * ROT_90_POWER;
	motor[backRight] = -sign * ROT_90_POWER;
	wait1Msec((int) (angle/90.0*1700));
}

void update() {
	if (manualControl) {
		// Left joystick controls left side
		int leftPower = vexRT[Ch3] / 4;
		// Right joystick controls right side
		int rightPower = vexRT[Ch2] / 4;

		// Boost
		if (vexRT[Btn6U]) {
			leftPower *= 2;
			rightPower *= 2;
		}
		// Brake
		if (vexRT[Btn5U]){
			leftPower = 0;
			rightPower = 0;
		}

		motor[frontLeft] = leftPower;
		motor[backLeft] = leftPower;
		motor[frontRight] = -rightPower;
		motor[backRight] = -rightPower;
	}
}

task main()
{
	//moveForward(50);
	//wait1Msec(1000);
	//moveForward(-50, 1000);
	//rotate(-50, 3000);
	manualControl = false;

	rotate(60);
	//moveForward(30.5);

	//while (true) {
	//	update();
	//}

}

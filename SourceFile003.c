#pragma config(Sensor, in1,    photo,          sensorReflection)
#pragma config(Sensor, in7,    temperature,    sensorAnalog)
#pragma config(Sensor, in8,    salinity,       sensorAnalog)
#pragma config(Sensor, dgtl1,  anemBack,       sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  ledGreen,       sensorDigitalOut)
#pragma config(Sensor, dgtl8,  ledRed,         sensorDigitalOut)
#pragma config(Sensor, dgtl10, ledOrange,      sensorDigitalOut)
#pragma config(Sensor, dgtl12, ledBlue,        sensorDigitalOut)
#pragma config(Motor,  port1,            ,             tmotorVex269_HBridge, openLoop)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           frontRight,    tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port6,           crane,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           flag,          tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port8,           flashlight,    tmotorVexFlashlight, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef struct {
	int speed;

} robot;

bool manualControl = true;

/*void moveForward(int power)
{
	motor[motorA] = -power;
	motor[motorB] = power;
	motor[motorC] = -power;
	motor[motorD] = power;
}*/

void moveForward(double dist)
{
	motor[frontLeft] = 127;
	motor[backLeft] = 127;
	motor[frontRight] = -127;
	motor[backRight] = -127;
	wait1Msec(dist * 9);
}

void rotate(int angle)
{
	int sign = 1;
	if (angle < 0) sign = -1;

	motor[frontLeft] = sign * 127;
	motor[backLeft] = sign * 127;
	motor[frontRight] = sign * 127;
	motor[backRight] = sign * 127;
	wait1Msec((int) ((angle/90.0)*700.0));
}

/*
Rotates the crane to a specified angle.
-50 is a good angle to lower the crane.
*/
void rotateCrane(int angle)
{
	motor[crane] = angle;
	//motor[crane] = 63;
	//setServo(crane, 127);
	wait1Msec(1000);
}

void setLed(int port, int val)
{
	SensorValue[port] = val;
}

void output4Bits(int num)
{
	setLed(ledBlue, (num & 1) >> 0);
	setLed(ledOrange, (num & 2) >> 1);
	setLed(ledRed, (num & 4) >> 2);
	setLed(ledGreen, (num & 8) >> 3);
	wait1Msec(2000);
	setLed(ledBlue, 0);
	setLed(ledOrange, 0);
	setLed(ledRed, 0);
	setLed(ledGreen, 0);
}

int isSalty() {
	int sal = SensorValue[salinity];
	return sal < 100;
}

int readWind() {
	int anemValue1 = SensorValue[anemBack];
	wait1Msec(10000);
	int anemValue2 = SensorValue[anemBack];

	return (anemValue2 - anemValue1) / 3600;
}

int readTemperature() {
	// Calibration: Degrees C = 108.86*e^(-0.026 * temp)
	int temp = SensorValue[temperature];

	int degrees = 108.87*exp(-0.026 * temp);

	return degrees;
}

void manualCtrl() {
	if (manualControl) {
		// Left joystick controls left side
		int leftPower = vexRT[Ch3];
		// Right joystick controls right side
		int rightPower = vexRT[Ch2];

		// Crane is 8L
		if (vexRT[Btn8L]) {
			rotateCrane(0);
		} else {
			rotateCrane(50);
		}



		motor[frontLeft] = leftPower;
		motor[backLeft] = leftPower;
		motor[frontRight] = -rightPower;
		motor[backRight] = -rightPower;
	}
}

void startRover() {
	rotateCrane(50);
	moveForward(1);
	//moveForward(1);
	//rotateCrane(-50);
//	rotate(180);

	while (true) {
	// Turn on flashlight
		motor[flashlight] = 127;

		if (manualControl) {
			// Use manual control if needed
			manualCtrl();
		} else {
			motor[frontLeft] = 0;
			motor[backLeft] = 0;
			motor[frontRight] = 0;
			motor[backRight] = 0;
		}

		if (vexRT[Btn7U]) {
			manualControl = !manualControl;
		}

	}
}

task main()
{
	manualControl = true;

	//output4Bits(SensorValue[salinity]);
	startRover();

}

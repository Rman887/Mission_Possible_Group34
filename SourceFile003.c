#pragma config(Sensor, in1,    photo,          sensorReflection)
#pragma config(Sensor, in7,    temperature,    sensorAnalog)
#pragma config(Sensor, in8,    salinity,       sensorAnalog)
#pragma config(Sensor, dgtl1,  anemBack,       sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  ledGreen,       sensorDigitalOut)
#pragma config(Sensor, dgtl8,  ledRed,         sensorDigitalOut)
#pragma config(Sensor, dgtl10, ledOrange,      sensorDigitalOut)
#pragma config(Sensor, dgtl12, ledBlue,        sensorDigitalOut)
#pragma config(Motor,  port1,            ,             tmotorVex269_HBridge, openLoop)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           frontRight,    tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port6,           crane,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           flag,          tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port8,           flashlight,    tmotorVexFlashlight, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Moves the robot forward a specified distance.
*/
void moveForward(double dist)
{
	motor[frontLeft] = 63;
	motor[backLeft] = 63;
	motor[frontRight] = -63;
	motor[backRight] = -63;
	wait1Msec(dist * 9);
}

/*
Rotates the robot a specified degrees clockwise.
*/
void rotate(int angle)
{
	int sign = 1;
	if (angle < 0) sign = -1;

	motor[frontLeft] = sign * 127;
	motor[backLeft] = sign * 127;
	motor[frontRight] = sign * 127;
	motor[backRight] = sign * 127;
	wait1Msec((int) ((angle/90.0)*700.0));
}

/*
Rotates the crane to a specified angle.
*/
void rotateCrane(int angle)
{
	motor[crane] = angle;
}

/*
Sets the value of the LED at a specified port
*/
void setLed(int port, int val)
{
	SensorValue[port] = val;
}

/*
Outputs the last 4 bits of the specified number to the LEDs.
*/
void output4Bits(int num)
{
	setLed(ledBlue, (num & 1) >> 0);
	setLed(ledOrange, (num & 2) >> 1);
	setLed(ledRed, (num & 4) >> 2);
	setLed(ledGreen, (num & 8) >> 3);
	wait1Msec(2000);
	setLed(ledBlue, 0);
	setLed(ledOrange, 0);
	setLed(ledRed, 0);
	setLed(ledGreen, 0);
	wait1Msec(2000);
}

/*
Checks whether the salinity sensor reports whether the water is salty.
*/
bool isSalty() {
	int sal = SensorValue[salinity];
	return sal < 700;
}

/*
Reads the wind speed from the anemometor in RPM.
*/
int readWind() {
	int anemValue1 = SensorValue[anemBack];
	wait1Msec(10000);
	int anemValue2 = SensorValue[anemBack];

	return (int) ((anemValue2-anemValue1)/60.0);
}

/*
Reads the temperature from the thermister.
*/
int readTemperature() {
	// Calibration: Degrees C = 108.86*e^(-0.026 * temp)
	int temp = SensorValue[temperature];

	int degrees = (int) (108.87*exp(-0.026 * temp));

	return degrees;

	//return 8;
}

task main()
{
	int salData[16];
	int salIndex = 0;
	bool canReadSal = true;
	
	int tempData[16];
	int tempIndex = 0;
	bool canReadTemp = true;
	
	int windData[16];
	int windIndex = 0;
	bool canReadWind = true;

	// The rover will respond to manual input (controller) when this is true
	bool manualControl = false;

	// Reset the servo crane
	rotateCrane(-50);
	bool craneDown = true;

	while (true) {
		// Keep the flashlight on
		motor[flashlight] = 127;

		// Use manual control if needed
		if (manualControl) {
			// Left joystick controls left side
			int leftPower = vexRT[Ch3] / 2;
			// Right joystick controls right side
			int rightPower = vexRT[Ch2] / 2;

			motor[frontLeft] = leftPower;
			motor[backLeft] = leftPower;
			motor[frontRight] = -rightPower;
			motor[backRight] = -rightPower;
		} else {
			// Wait 5 secs after landing
			wait1Msec(5000);
			
			// Read wind speed
			int wind = readWind();
			windData[windIndex++] = wind;
			
			// Crane up
			rotateCrane(120);
			wait1Msec(5000);
			
			// Move to salt lake
			moveForward(60);
			wait1Msec(1000);
			
			// Crane down
			for (int i = 0; i < 5; i++) {
				rotateCrane(-10 * i);
				wait1Msec(300);
			}
			
			// Read salt
			bool salty = isSalty();
			if (salty) {
				salData[salIndex++] = 3;
			} else {
				salData[salIndex++] = 2;
			}
			
			// Manual
			manualControl = true;
		}

		// Let the 7U button toggle manual movement
		if (vexRT[Btn7U]) {
			manualControl = !manualControl;
		}

		// Crane is 7D
		if (vexRT[Btn7D]) {
			craneDown = !craneDown;
			if (craneDown) {
				for (int i = 0; i < 5; i++) {
					rotateCrane(-10 * i);
					wait1Msec(300);
				}
			} else {
				rotateCrane(120);
				wait1Msec(1000);
			}
		}

		// Flag is 7R
		if (vexRT[Btn7R]) {
			motor[flag] = 127;
			wait1Msec(5000);
		} else {
			motor[flag] = 0;
		}

		// Output temperature
		if (vexRT[Btn8U]) {
			if (canReadTemp) {
				int temp = readTemperature();
				tempData[tempIndex++] = temp;
				canReadTemp = false;
			}
		}
		else canReadTemp = true;
		
		// Output salinity
		if (vexRT[Btn8L]) {
			if (canReadSal) {
				wait1MSec(10000);
	
				bool salty = isSalty();
				if (salty) {
					salData[salIndex++] = 3;
				} else {
					salData[salIndex++] = 2;
				}
				
				canReadSal = false;
			}
		}
		else canReadSal = true;
		
		// Output wind speed
		if (vexRT[Btn8D]) {
			if (canReadWind) {
				int wind = readWind();
				windData[windIndex++] = wind;
				canReadWind = false;
			}
		}
		else canReadWind = true;

		// Stop
		if (vexRT[Btn7L]) {
			break;
		}
	}

	for (int i = 0; i < salIndex; i++) {
		output4Bits((salData[i] >> 4) & 0xF);
		output4Bits(salData[i] & 0xF);
	}
	output4Bits(0xF);
	for (int i = 0; i < tempIndex; i++) {
		output4Bits((tempData[i] >> 4) & 0xF);
		output4Bits(tempData[i] & 0xF);
	}
	output4Bits(0xF);
	for (int i = 0; i < windIndex; i++) {
		output4Bits((windData[i] >> 4) & 0xF);
		output4Bits(windData[i] & 0xF);
	}
}
